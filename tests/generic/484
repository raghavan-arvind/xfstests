#! /bin/bash
# SPDX-License-Identifier: GPL-2.0
# Copyright (c) 2020 The University of Texas at Austin.  All Rights Reserved.
#
# FS QA Test 484
#
# Test case created by CrashMonkey
#
# Test if we create a rename a file and persist it that the
# appropriate files exist.
#
seq=`basename $0`
seqres=$RESULT_DIR/$seq
echo "QA output created by $seq"

here=`pwd`
tmp=/tmp/$$
status=1	# failure is the default!
trap "_cleanup; exit \$status" 0 1 2 3 15

_cleanup()
{
	_cleanup_flakey
	cd /
	rm -f $tmp.*
}

# get standard environment, filters and checks
. ./common/rc
. ./common/filter
. ./common/dmflakey

# remove previous $seqres.full before test
rm -f $seqres.full

# real QA test starts here
_supported_fs generic
_supported_os Linux
_require_scratch_nocheck
_require_dm_target flakey

# initialize scratch device
_scratch_mkfs > $seqres.full 2>&1
_require_metadata_journaling $SCRATCH_DEV
_init_flakey
_mount_flakey

testdir=$SCRATCH_MNT/testdir
mkdir $testdir

stat_opt='-c  %n - blocks: %b size: %s inode: %i links: %h'

# Usage: general_stat [--data-only] file1 [--data-only] [file2] ..
# If the --data-only flag precedes a file, then only that file's
# data will be printed. If a file is synced, then general_stat
# should provide identical output before and after a crash.
general_stat() {
	local data_only="false"
	while (( "$#" )); do
		case $1 in
			--data-only)
				data_only="true"
				;;
			*)
				local path="$1"
				echo "-- $path --"
				if [ ! -e "$path" ]; then
					echo "Doesn't exist!"
				elif [ "$data_only" = "true" ] && [ -d "$path" ]; then
					echo "Directory Data"
					[ -z "$(ls -A $path)" ] || ls -1 "$path" | sort
				elif [ "$data_only" = "true" ]; then
					echo "File Data"
					od "$path"
				elif [ -d "$path" ]; then
					echo "Directory Metadata"
					stat "$stat_opt" "$path"
					echo "Directory Data"
					[ -z "$(ls -A $path)" ] || ls -1 "$path" | sort
				else
					echo "File Metadata"
					stat "$stat_opt" "$path"
					echo "File Data"
					od "$path"
				fi
				data_only="false"
				;;
		esac
		shift
	done
}

check_consistency()
{
	local file="$1"
	local sync_op="$2"

	$XFS_IO_PROG -c $sync_op $file

	before=$(general_stat $file)
	_flakey_drop_and_remount
	after=$(general_stat $file)

	if [ "$before" != "$after" ]; then
		echo -e "Before:\n$before"
		echo -e "After:\n$after"
	fi

	_unmount_flakey
	_check_scratch_fs $FLAKEY_DEV
}

clean_dir()
{
	_mount_flakey
	rm -rf $testdir/*
}

# Wraps mv, deletes dest dir if exists.
rename() {
	[ -d $1 ] && [ -d $2 ] && rm -rf $2
	mv $1 $2
}

function rename_template() {
	local file1="$1"
	local file2="$2"
	local fsync_file="$3"
	local fsync_command="$4"

	mkdir -p $(dirname $file1)
	touch $file1
	mkdir -p $(dirname $file2)
	rename $file1 $file2
	check_consistency $fsync_file $fsync_command
	clean_dir
}

file1_options=(
	"$testdir/A/C/bar"
	"$testdir/A/bar"
	"$testdir/A/foo"
	"$testdir/foo"
)
file2_options=(
	"$testdir/A/C/bar"
	"$testdir/A/bar"
	"$testdir/bar"
)

for file1 in ${file1_options[@]}; do
	for file2 in ${file2_options[@]}; do
		[ "$file1" == "$file2" ] && continue
		to_sync=("$(dirname $file1)" "$(dirname $file2)")
		uniques=($(for v in ${to_sync[@]}; do echo $v; done | sort -u))
		for fsync_file in ${uniques[@]}; do
			for fsync_command in fsync fdatasync; do
				rename_template $file1 $file2 $fsync_file $fsync_command
			done
		done
	done
done

# Success, all done
echo "Silence is golden"
status=0
exit
